--- 
title_meta  : Chapter 6
title       : More on Data Frames
description : Most data sets you will be working with will be stored as a data frame. Learn data frame operations will help your data analysis procedure.


--- type:NormalExercise lang:r xp:100 skills:1 key:f625f0fd8d
## Filtering Data Frames Using subset()

Filtering means extracting rows from a data frame that satisfy a logical condition, Data frames can be ﬁltered using boolean vectors and brackets "[]" operators, The function subset() ﬁlters data frames, by applying logical conditions to its columns, using the column names, subset() provides a succinct notation and discards NA values, but it’s slightly slower than using boolean vectors and brackets "[]" operators.


*** =instructions
- Use `subset()` to filter dataframe.

*** =hint
Follow the instruction and introduction. 

*** =pre_exercise_code
```{r}
```

*** =sample_code

```{r}
# load the package microbenchmark


# filter airquality


# filter airquality by subset


# use microbenchmark to compare speed

```

*** =solution
```{r}
# load the package microbenchmark
library(microbenchmark)

# filter airquality
airquality[(airquality$Solar.R>320 &
        !is.na(airquality$Solar.R)), ]

# filter airquality by subset
subset(x=airquality, subset=(Solar.R>320))

# use microbenchmark to compare speed
summary(microbenchmark(
    subset=subset(x=airquality, subset=(Solar.R>320)),
    brackets=airquality[(airquality$Solar.R>320 &
            !is.na(airquality$Solar.R)), ],
times=10))[, c(1, 4, 5)]
```

*** =sct
```{r}
test_error()
success_msg("Yes! Now you know how to deal with a function!")
```
--- type:NormalExercise lang:r xp:100 skills:1 key:d4ddcf9a7d
## Splitting Data Frames Using factor Categorical Variables

The function split() divides an object into a list of objects, according to a factor (categorical variable), The list’s names attribute is equal to the factor level.

*** =instructions
- Split the dataframe according to factor. Use the Iris dataframe.

*** =hint
Follow the instruction and introductions.

*** =pre_exercise_code
```{r}
# no pec
```

*** =sample_code
```{r}
# Species has three distinct values


# Create separate data frame for setosa frames by hand according to Species


# Create separate data frame for versicolor by hand according to Species


# Create separate data frame for virginica by hand according to Species


# get the dimension of new dataframe about setosa


# get the first two rows of new setosa dataframe

```

*** =solution
```{r}
# Species has three distinct values
unique(iris$Species)

# Create separate data frame for setosa frames by hand according to Species
set_osa <- iris[iris$Species=="setosa", ]

# Create separate data frame for versicolor by hand according to Species
versi_color <- iris[iris$Species=="versicolor", ]

# Create separate data frame for virginica by hand according to Species
virgin_ica <- iris[iris$Species=="virginica", ]

# get the dimension of new dataframe about setosa
dim(set_osa)

# get the first two rows of new setosa dataframe
head(set_osa, 2)
```

*** =sct
```{r}
test_error()
success_msg("Wonderful!")
```


--- type:NormalExercise lang:r xp:100 skills:1 key:c8f389fdbd
## The split-apply-combine Procedure Example

The split-apply-combine procedure consists of: dividing an object into a list, according to a factor (attribute), applying a function to each list element, combining the results.

The split-apply-combine procedure is similar to pivot tables in Excel, The split-apply-combine procedure, by Hadley Wickham: (http://www.jstatsoft.org/v40/i01/paper)

The split-apply-combine procedure can be performed through successive applications of functions split(), apply(), and unlist().

The aggregate() functional performs the split-apply-combine procedure, by applying a function to groups of an object, aggregate() returns a data frame containing the names of the groups.

*** =instructions
- Conduct split-apply-aggregate on mtcars dataset

*** =hint
Remember we learnt `split()` for split procedure, the `*apply()` family for apply and we use `aggregate()` for aggregation.

*** =pre_exercise_code
```{r}
# no pec
```

*** =sample_code
```{r}
# split iris into list based on Species


# have a look to the structure of splitted dataframe


# get the name attributes


# get the dimension attributes


# get the first two rows


# cyl has three unique values


# split mtcars data frame based on number of cylinders


# have a look to the structure of splitted dataframe


# get the name attributes


# mean mpg for each cylinder group


# function aggregate() performs split-apply-combine


# aggregate() all columns

```

*** =solution
```{r}
# split iris into list based on Species
split_iris <- split(iris, iris$Species)

# have a look to the structure of splitted dataframe
str(split_iris, max.level=1)

# get the name attributes
names(split_iris)

# get the dimension attributes
dim(split_iris$setosa)

# get the first two rows
head(split_iris$setosa, 2)

# cyl has three unique values
unique(mtcars$cyl)

# split mtcars data frame based on number of cylinders
split_cars <- split(mtcars, mtcars$cyl)

# have a look to the structure of splitted dataframe
str(split_cars, max.level=1)

# get the name attributes
names(split_cars)

# mean mpg for each cylinder group
unlist(lapply(split_cars, function(x) mean(x$mpg)))

# function aggregate() performs split-apply-combine
aggregate(formula=(mpg ~ cyl), data=mtcars, FUN=mean)

# aggregate() all columns
aggregate(x=mtcars, by=list(cyl=mtcars$cyl), FUN=mean)
```

*** =sct
```{r}
test_function("str","object",incorrect_msg = "Make sure to check the structure of the `mtcars` data set.")
test_output_contains("str(mtcars)", incorrect_msg = "Make sure that you use the [`str()`](http://www.rdocumentation.org/packages/utils/functions/str) function on `mtcars`.")
success_msg("Nice work!")
```


--- type:NormalExercise lang:r xp:100 skills:1 key:f09c0189ac
## The tapply() Functional

The `tapply()` functional is a specialized version of the `apply()` functional, that applies a function to elements of a jagged array, A jagged array is a list consisting of elements which are vectors (or matrices) of diﬀerent lengths, `tapply()` accepts a vector of values "X", a factor "INDEX", and a function "FUN", `tapply()` ﬁrst groups the elements of "X" according to the factor "INDEX", transforming it into a jagged array, and then applies "FUN" to each element of the jagged array, `tapply()` applies a function to sub-vectors aggregated using a factor, and performs the whole split-apply-combine procedure in a single function call, The `by()` function is a wrapper for `tapply()`, The `with()` function evaluates an expression in an environment constructed from the data

*** =instructions
- Use `tapply()` to finish the split-apply-combine process altogether!

*** =hint
Carefully follow the instruction and introduction. Also you can use `?tapply()` for more information and examples.

*** =pre_exercise_code
```{r}
# no pec
```

*** =sample_code
```{r}
# mean mpg for each cylinder group


# using with() environment


# function sapply() instead of tapply()


# function by() instead of tapply()

```

*** =solution
```{r}
# mean mpg for each cylinder group
tapply(X=mtcars$mpg, INDEX=mtcars$cyl, FUN=mean)

# using with() environment
with(mtcars, tapply(X=mpg, INDEX=cyl, FUN=mean))

# function sapply() instead of tapply()
with(mtcars,
     sapply(sort(unique(cyl)), function(x) {
       structure(mean(mpg[x==cyl]), names=x)
       }, USE.NAMES=TRUE))

# function by() instead of tapply()
with(mtcars, by(data=mpg, INDICES=cyl, FUN=mean))
```

*** =sct
```{r}
success_msg("Great job!")
```

--- type:NormalExercise lang:r xp:100 skills:1 key:7090dc3538
## The split-apply-combine Returning Matrices Example

Sometimes the split-apply-combine procedure returns a list of vectors, A list of vectors can be ﬂattened into a matrix using the functions `do.call()` and either `rbind()` or `cbind()`, The function `do.call()` executes a function call using a function name and a list of arguments, do.call() passes the list elements individually, instead of passing the whole list as one argument: 

````
do.call(fun, list)= fun(list[[1]], list[[2]], ...)
````

*** =instructions
- Use split-apply-combine to flatten returned results.

*** =hint
Follow the instruction and introduction!

*** =pre_exercise_code
```{r}
# no pec
```

*** =sample_code
```{r}
# get several mpg stats for each cylinder group
data_cars <- sapply(split_cars,
      function(x) {
        c(mean=mean(x$mpg), max=max(x$mpg), min=min(x$mpg))
      }
      )

# sapply produces a matrix


# now same using lapply with anonymous function


# lapply produces a list


# do.call flattens list into a matrix

```

*** =solution
```{r}
# get several mpg stats for each cylinder group
data_cars <- sapply(split_cars,
      function(x) {
        c(mean=mean(x$mpg), max=max(x$mpg), min=min(x$mpg))
      }
      )

# sapply produces a matrix
data_cars

# now same using lapply with anonymous function
data_cars <- lapply(split_cars,
      function(x) {
        c(mean=mean(x$mpg), max=max(x$mpg), min=min(x$mpg))
      }
      )

# lapply produces a list
is.list(data_cars)

# do.call flattens list into a matrix
do.call(cbind, data_cars)
```

*** =sct
```{r}
success_msg("That looks more beautiful! Head over to the next exercise.")
```


--- type:NormalExercise lang:r xp:100 skills:1 key:a80ae7fbe8
## Benchmarking the Speed of R Code

The function system.time() calculates the execution time (in seconds) used to evaluate a given expression, system.time() returns the ”user time” (execution time of user instructions), the ”system time” (execution time of operating system calls), and ”elapsed time” (total execution time, including system latency waiting), The function microbenchmark() from package microbenchmark calculates and compares the execution time of R expressions (in milliseconds), and is more accurate than system.time(), microbenchmark() executes the expression many times, and returns the distribution of total execution times.

*** =instructions
- Test the speed to certain code with microbenchmark

*** =hint
Follow the instruction and introduction.

*** =pre_exercise_code
```{r}
# no pec
```

*** =sample_code
```{r}
# import microbenchmark package


# create vector
foo <- runif(1e6)

# lock time for single operation


# compare time for different operations

```

*** =solution
```{r}
# import microbenchmark package
library(microbenchmark)

# create vector
foo <- runif(1e6)

# lock time for single operation
system.time(foo^0.5)

# compare time for different operations
microbenchmark(sqrt(foo), foo^0.5, times=10)
```

*** =sct
```{r}
success_msg("Nice one! This is going fast!")
```
--- type:NormalExercise lang:r xp:100 skills:1 key:b6125af738
## Writing Fast R Code Using Compiled Functions

Compiled functions directly call compiled C++ or Fortran code, which performs the calculations and returns the result back to R, This makes compiled functions much faster than interpreted functions, which have to be parsed by R, `sum()` is much faster than mean(), because `sum()` is a compiled function, while `mean()` is an interpreted function, Given a single argument, any() is equivalent to %in%, but is much faster because it’s a compiled function, %in% is a wrapper for match() deﬁned as follows: `"%in%" <- function(x, table) match(x, table, nomatch=0) > 0`.

*** =instructions
- Compare the speed of complied and uncompiled functions.

*** =hint
Follow the instruction and introductions. Be careful that to see information about a function you can't add `()` after function name.

*** =pre_exercise_code
```{r}
library(microbenchmark)
```

*** =sample_code
```{r}
# sum() is a compiled primitive function


# mean() is a generic function


# create large vector


# change code, sum() is much faster than mean()
summary(
  (sum(foo), mean(foo), times=10)
  )[, c(1, 4, 5)]

# any() is a compiled primitive function


# any() is much faster than %in% wrapper for match()

```

*** =solution
```{r}
# sum() is a compiled primitive function
sum

# mean() is a generic function
mean

# create large vector
foo <- runif(1e6)

# change code, sum() is much faster than mean()
summary(
  microbenchmark(sum(foo), mean(foo), times=10)
  )[, c(1, 4, 5)]

# any() is a compiled primitive function
any

# any() is much faster than %in% wrapper for match()
summary(
  microbenchmark(any(foo == 1), {1 %in% foo}, times=10)
  )[, c(1, 4, 5)]
```

*** =sct
```{r}
success_msg("Great!")
```

--- type:NormalExercise lang:r xp:100 skills:1 key:7aa0a94261
## Writing Fast R Code Without Method Dispatch

As a general rule, calling generic functions is slower than directly calling individual methods, because generic functions must execute extra R code for method dispatch, The generic function as.data.frame() coerces matrices and other objects into data frames, The method `as.data.frame.matrix()` coerces only matrices into data frames, `as.data.frame.matrix()` is about 50% faster than `as.data.frame()`, because it skips extra R code in `as.data.frame()` needed for argument validation, error checking, and method dispatch, Users can create even faster functions of their own by extracting only the essential R code into their own specialized functions, ignoring R code needed to handle diﬀerent types of data, Such specialized functions are faster but less ﬂexible, so they may fail with diﬀerent types of data.


*** =instructions
- Skip the method dispatch procedure to speed up your code!

*** =hint
Follow the instruction and introduction.

*** =pre_exercise_code
```{r}

```

*** =sample_code
```{r}
# load microbenchmark package


# create matrix
mat_rix <- matrix(1:9, ncol=3,
  dimnames=list(paste0("row", 1:3),
          paste0("col", 1:3)))

# change the code to create specialized function
matrix_to_dframe <- function(mat_rix) {
  n_col <- ncol(mat_rix)
  dframe <- vector("list", 2)
  for(in_dex in 1:n_col)
    dframe <- mat_rix[, in_dex]
  attr(dframe, "row.names") <-
    .set_row_names(row(mat_rix))
  attr(dframe, "class") <- "data.frame"
  dframe
}

# compare speed of three methods

```

*** =solution
```{r}
# load microbenchmark package
library(microbenchmark)

# create matrix
mat_rix <- matrix(1:9, ncol=3,
  dimnames=list(paste0("row", 1:3),
          paste0("col", 1:3)))

# change the code to create specialized function
matrix_to_dframe <- function(mat_rix) {
  n_col <- ncol(mat_rix)
  dframe <- vector("list", n_col)
  for(in_dex in 1:n_col)
    dframe <- mat_rix[, in_dex]
  attr(dframe, "row.names") <-
    .set_row_names(NROW(mat_rix))
  attr(dframe, "class") <- "data.frame"
  dframe
}

# compare speed of three methods
summary(microbenchmark(
  matrix_to_dframe(mat_rix),
  as.data.frame.matrix(mat_rix),
  as.data.frame(mat_rix),
  times=10))[, c(1, 4, 5)]
```

*** =sct
```{r}
success_msg("Great! Continue to the next exercise and discover yet another way of subsetting!")
```


--- type:NormalExercise lang:r xp:100 skills:1 key:d6245c1bb1
## Using apply() Instead of for() and while() Loops

All the diﬀerent R loops have similar speed, with `apply()` the fastest, then `vapply()`, `lapply()` and `sapply()` slightly slower, and `for()` loops the slowest.

More importantly, the `apply()` syntax is more readable and concise, and ﬁts the functional language paradigm of R, so is therefore preferred obver `for()` loops, Both `vapply()` and `lapply()` are compiled (primitive) functions, and therefore can be faster than other `apply()` functions

*** =instructions
- Compare speed of `*apply()` family and `for()`

*** =hint
Avoid `for()` loop in R.


*** =pre_exercise_code
```{r}
```

*** =sample_code
```{r}
# matrix with 5,000 rows
big_matrix <- matrix(rnorm(10000), ncol=2)

# allocate memory for row sums


# change the code to compare speed of *apply() family and for() loop
summary(microbenchmark(
  ap_ply=apply(big_matrix, 1, sum),
  l_apply=apply(1:NROW(big_matrix), function(in_dex)
    sum(big_matrix[in_dex, ])),
  v_apply=apply(1:NROW(big_matrix), function(in_dex)
    sum(big_matrix[in_dex, ]),
    FUN.VALUE=c(sum=0)),
  s_apply=apply(1:NROW(big_matrix), function(in_dex)
    sum(big_matrix[in_dex, ])),
  for_loop=for(i in 1:NROW(big_matrix)) {
    row_sums[i] <- sum(big_matrix[in_dex,])
  },
  ))[, c(1, 4, 5)]
```

*** =solution
```{r}
# matrix with 5,000 rows
big_matrix <- matrix(rnorm(10000), ncol=2)

# allocate memory for row sums
row_sums <- numeric(NROW(big_matrix))

# change the code to compare speed of *apply() family and for() loop
summary(microbenchmark(
  ap_ply=apply(big_matrix, 1, sum),
  l_apply=lapply(1:NROW(big_matrix), function(in_dex)
    sum(big_matrix[in_dex, ])),
  v_apply=vapply(1:NROW(big_matrix), function(in_dex)
    sum(big_matrix[in_dex, ]),
    FUN.VALUE=c(sum=0)),
  s_apply=sapply(1:NROW(big_matrix), function(in_dex)
    sum(big_matrix[in_dex, ])),
  for_loop=for(i in 1:NROW(big_matrix)) {
    row_sums[i] <- sum(big_matrix[i,])
  },
  times=10))[, c(1, 4, 5)]
```

*** =sct
```{r}
success_msg("Nice work!")
```


--- type:NormalExercise lang:r xp:100 skills:1 key:c1a08e245c
## Only planets with rings but shorter

So what exactly did you learn in the previous exercises? You selected a subset from a data frame (`planets_df`) based on whether or not a certain condition was true (rings or no rings), and you managed to pull out all relevant data. Pretty awesome! By now, NASA is probably already flirting with your CV!

Instead of having to define a vector `rings_vector`, which you then use to subset `planets_df`, you could've also used either one of these:

```
planets_df[planets_df$has_rings, ]
planets_df[planets_df$has_rings == TRUE, ]
```

*** =instructions
- Create a data frame `small_planets_df` with planets that have a diameter smaller than the Earth. This means that the `diameter` variable should be smaller than 1, since diameter is a relative measure of the planet's diameter in relation to planet Earth.
- Build another data frame, `slow_planets_df`, with the observations that have a longer rotation period than Earth. This means that the absolute value (use the function [`abs()`](http://www.rdocumentation.org/packages/base/functions/MathFun)) of the `rotation` variable should be greater than 1.

*** =hint
Make use of the logical operators `>` and `<`. Use the [`abs()`](http://www.rdocumentation.org/packages/base/functions/MathFun) function for absolute values. 

*** =pre_exercise_code
```{r}
load(url("http://s3.amazonaws.com/assets.datacamp.com/course/introduction_to_r/chapter6.RData"))
```

*** =sample_code
```{r}
# planets_df is pre-loaded in your workspace

# Planets that are smaller than planet Earth: small_planets_df


# Planets that rotate slower than planet Earth: slow_planets_df

```

*** =solution
```{r}
# planets_df is pre-loaded in your workspace

# Planets that are smaller than planet Earth: small_planets_df
small_planets_df <- planets_df[planets_df$diameter < 1, ]        # option 1
small_planets_df  <- subset(planets_df, subset = diameter < 1)   # option 2

# Planets that rotate slower than planet Earth: slow_planets_df
slow_planets_df <- planets_df[abs(planets_df$rotation) > 1, ]      # option 1
slow_planets_df <- subset(planets_df, subset = abs(rotation) > 1)  # option 2
```

*** =sct
```{r}

msg <- "Do not remove or overwrite the `planets_df` data frame!"
test_object("planets_df", undefined_msg = msg, incorrect_msg = msg)

test_object("small_planets_df",
            incorrect_msg = "It looks like `small_planets_df` does not contain the correct subset of `planets_df`.")

test_object("slow_planets_df",
            incorrect_msg = "It looks like `slow_planets_df` does not contains the correct subset of `planets_df`. Make sure to use the [`abs()`](http://www.rdocumentation.org/packages/base/functions/MathFun) function for absolute values.")

success_msg("Great! Not only is the [`subset()`](http://www.rdocumentation.org/packages/base/functions/subset) function more concise, it is probably also more understandable for people who read your code. Continue to the next exercise.")
```


--- type:NormalExercise lang:r xp:100 skills:1 key:e9ca3eeb99
## Add variable/column

There are many cases in which you'll want to add more variables to your data frame. This comes down to adding a column to the data frame. The exact same techniques to select columns from a data frame can be used here. To add a column `new_column` to `my_df`, with data from `my_vec`, you can use one of the following calls:

```
my_df$new_column <- my_vec
my_df[["new_column"]] <- my_vec
my_df <- cbind(my_df, new_column = my_vec)
```

You've browsed [Wikipedia](https://en.wikipedia.org/wiki/Planet) and also decide to add a column that lists the number of moons each of the planets has. Also the planets' masses can be a cool addition. The `moon` and `masses` vectors are already included in the workspace; up to you to add them to `planets_df`.

*** =instructions
- Add `moons` to `planets_df` under the variable name "moon".
- In a similar fashion, add `masses` under the variable name `"mass"`.

*** =hint
To add a new column called "moon", you can use: `planets_df$moon <- moons`.

*** =pre_exercise_code
```{r}
load(url("http://s3.amazonaws.com/assets.datacamp.com/course/introduction_to_r/chapter6.RData"))
```

*** =sample_code
```{r}
# planets_df is already pre-loaded in your workspace

# Definition of moons and masses
moons <- c(0, 0, 1, 2, 67, 62, 27, 14)
masses <- c(0.06, 0.82, 1.00, 0.11, 317.8, 95.2, 14.6, 17.2)

# Add moons to planets_df under the name "moon"


# Add masses to planets_df under the name "mass"

```

*** =solution
```{r}
# planets_df is already pre-loaded in your workspace

# Definition of moons and masses
moons <- c(0, 0, 1, 2, 67, 62, 27, 14)
masses <- c(0.06, 0.82, 1.00, 0.11, 317.8, 95.2, 14.6, 17.2)

# Add moons to planets_df under the name "moon"
planets_df$moon <- moons

# Add masses to planets_df under the name "mass"
planets_df$mass <- masses
```

*** =sct
```{r}

undef_msg <- "Do not remove `planets_df`!"
msg <- "Do not change anything about the columns that were already in `planets_df`; you should only <i>add</i> columns."
test_data_frame(name = "planets_df", 
                columns = c("name", "type", "diameter", "rotation", "has_rings"),
                undefined_msg = undef_msg, undefined_cols_msg = msg, incorrect_msg = msg)

test_data_frame(name = "planets_df",
                columns = "moon",
                undefined_cols_msg = "Make sure to name the column to contain the moon information \"moon\".",
                incorrect_msg = "The \"moon\" column does not contain the correct information. Try again.")

test_data_frame(name = "planets_df",
                columns = "mass",
                undefined_cols_msg = "Make sure to name the column to contain the mass information \"mass\".",
                incorrect_msg = "The \"mass\" column does not contain the correct information. Try again.")

test_object("planets_df", incorrect_msg = "It appears that you have correctly specified the \"moon\" and \"mass\" columns, but there's still something wrong with the resulting `planets_df`. Make sure to add columns twice!")
success_msg("Nice one! This data frame is beginning to contain quite some information!")
```


--- type:NormalExercise lang:r xp:100 skills:1 key:8e5ade7078
## Sorting

In data analysis you will often sort your data according to a certain variable in the data set. In R, this is done with the help of the function [`order()`](http://www.rdocumentation.org/packages/base/functions/order). 

[`order()`](http://www.rdocumentation.org/packages/base/functions/order) is a function that gives you the ranked position of each element when it is applied on a variable, such as a vector for example:

```
a <- c(100,9,101)
order(a)
``` 

this code returns the vector containing 2, 1 and 3; that's because 100 is the second largest element of the vector, 9 is the smallest element and 101 is the largest element.
    
```
a[order(a)]
```

will thus give you the ordered vector (9, 100, 101), since it first picks the second element of `a`, then the first and then the last. Got it? If you are not sure, use the console to play with the [`order()`](http://www.rdocumentation.org/packages/base/functions/order) function. 

*** =instructions
Experiment with the [`order()`](http://www.rdocumentation.org/packages/base/functions/order) function in the console. Click 'Submit Answer' when you are ready to continue.

*** =hint
Just play with the [`order()`](http://www.rdocumentation.org/packages/base/functions/order) function in the console!

*** =pre_exercise_code
```{r}
# no pec
```

*** =sample_code
```{r}
# Just play around with the order function in the console to see how it works!
```

*** =solution
```{r}
# Just play around with the order function in the console to see how it works!
# Some examples:
order(1:10)
order(2:11)
order(c(5,4,6,7))
```

*** =sct
```{r}
success_msg("Great! Now let's use the [`order()`](http://www.rdocumentation.org/packages/base/functions/order) function to sort your data frame!")
```


--- type:NormalExercise lang:r xp:100 skills:1 key:ec87541ef1
## Sorting your data frame

Alright, now let us do something useful with the [`order()`](http://www.rdocumentation.org/packages/base/functions/order) function! You would like to rearrange your data frame such that it starts with the smallest planet and ends with the largest one. A sort on the `diameter` column, if you will.

Suppose you have a data frame `df`, with three columns `a`, `b` and `c`. The following code will print a version of df that is sorted on the column `a`.

```
pos <- order(df$a)
df[pos, ]
```

*** =instructions
- Assign to the variable `positions` the desired ordering for the new data frame that you will create in the next step. You can use the [`order()`](http://www.rdocumentation.org/packages/base/functions/order) function for that.
- Now create the data frame `smallest_first_df`, which contains the same information as `planets_df`, but with the planets in increasing order of magnitude. Use the previously created variable `positions` as row indices inside square brackets to achieve this.
- Print `smallest_first_df` to see what you've accomplished.

*** =hint
- `order(planets_df$diameter)` will give you the ordering of the variable diameter from smallest to largest. This is what you should assign to `positions`.
- Use the variable positions then to select from the data frame `planets_df`: `planets_df[positions, ]`.

*** =pre_exercise_code
```{r}
load(url("http://s3.amazonaws.com/assets.datacamp.com/course/introduction_to_r/chapter6.RData"))
```

*** =sample_code
```{r}
# planets_df is pre-loaded in your workspace

# Create a desired ordering for planets_df: positions


# Create a new, ordered data frame: smallest_first_df


# Print smallest_first_df
```

*** =solution
```{r}
# planets_df is pre-loaded in your workspace

# Create a desired ordering for planets_df: positions
positions <- order(planets_df$diameter)

# Create a new, ordered data frame: smallest_first_df
smallest_first_df <- planets_df[positions, ]

# Print smallest_first_df
smallest_first_df
```

*** =sct
```{r}
msg = "Do not remove or overwrite the `planets_df` data frame!"
test_object("planets_df", undefined_msg = msg, incorrect_msg = msg)
test_object("positions",
            incorrect_msg = "It looks like `positions` does not contain all the correct ordering of the diameter column.")
test_object("smallest_first_df",
            incorrect_msg = "It looks like `smallest_first_df` does not contain the positions of the ordered `planets_df`.")
test_output_contains("smallest_first_df", incorrect_msg = "Finish off by printing `smallest_first_df`.")
success_msg("Wonderful! What does the resulting data frame look like? Order prevailed!")
```

